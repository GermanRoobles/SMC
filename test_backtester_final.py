#!/usr/bin/env python3
"""
RESUMEN FINAL: TEST DEL BACKTESTER SMC
=====================================

Prueba final del backtester SMC completamente funcional
mostrando todas las capacidades implementadas.
"""

from fetch_data import get_ohlcv
from smc_trade_engine import TradeSignal, SignalType, ConfirmationType
from smc_backtester import SMCBacktester, run_backtest_analysis
import pandas as pd
from datetime import datetime

def create_realistic_signals(df, symbol, timeframe):
    """Crear se√±ales con niveles realistas de SL/TP basados en volatilidad"""
    signals = []

    # Analizar volatilidad del dataset
    price_min = df['low'].min()
    price_max = df['high'].max()
    price_range = price_max - price_min
    volatility_pct = (price_range / price_min) * 100

    # Calcular niveles adaptativos basados en volatilidad
    # Para volatilidad baja (<3%), usar niveles m√°s ajustados
    if volatility_pct < 3.0:
        sl_pct = 0.005  # 0.5%
        tp_pct = 0.008  # 0.8%
    elif volatility_pct < 5.0:
        sl_pct = 0.008  # 0.8%
        tp_pct = 0.015  # 1.5%
    else:
        sl_pct = 0.015  # 1.5%
        tp_pct = 0.025  # 2.5%

    print(f"   üìä Volatilidad detectada: {volatility_pct:.2f}%")
    print(f"   üéØ Niveles adaptativos: SL ¬±{sl_pct*100:.1f}%, TP ¬±{tp_pct*100:.1f}%")

    # Se√±al 1: LONG con niveles realistas
    entry_price = df['close'].iloc[20]
    signals.append(TradeSignal(
        timestamp=df['timestamp'].iloc[20],
        symbol=symbol,
        timeframe=timeframe,
        signal_type=SignalType.LONG,
        entry_price=entry_price,
        stop_loss=entry_price * (1 - sl_pct),
        take_profit=entry_price * (1 + tp_pct),
        risk_reward=tp_pct / sl_pct,
        confidence=0.85,
        setup_components={'fvg': True, 'order_block': True},
        confirmation_type=ConfirmationType.ENGULFING
    ))

    # Se√±al 2: SHORT con niveles realistas
    entry_price = df['close'].iloc[40]
    signals.append(TradeSignal(
        timestamp=df['timestamp'].iloc[40],
        symbol=symbol,
        timeframe=timeframe,
        signal_type=SignalType.SHORT,
        entry_price=entry_price,
        stop_loss=entry_price * (1 + sl_pct),
        take_profit=entry_price * (1 - tp_pct),
        risk_reward=tp_pct / sl_pct,
        confidence=0.75,
        setup_components={'fvg': True, 'liquidity': True},
        confirmation_type=ConfirmationType.REJECTION_WICK
    ))

    # Se√±al 3: LONG con niveles ligeramente m√°s amplios
    entry_price = df['close'].iloc[60]
    signals.append(TradeSignal(
        timestamp=df['timestamp'].iloc[60],
        symbol=symbol,
        timeframe=timeframe,
        signal_type=SignalType.LONG,
        entry_price=entry_price,
        stop_loss=entry_price * (1 - sl_pct * 1.2),
        take_profit=entry_price * (1 + tp_pct * 1.2),
        risk_reward=(tp_pct * 1.2) / (sl_pct * 1.2),
        confidence=0.80,
        setup_components={'order_block': True, 'bos': True},
        confirmation_type=ConfirmationType.HAMMER
    ))

    return signals

def final_backtester_test():
    """Test final del backtester SMC"""

    print("="*80)
    print("üéØ RESUMEN FINAL: BACKTESTER SMC COMPLETAMENTE FUNCIONAL")
    print("="*80)

    try:
        # 1. Obtener datos de mercado reales
        print("\nüìä CONFIGURACI√ìN DEL TEST:")
        symbol = 'BTCUSDT'
        timeframe = '1h'
        limit = 100

        df = get_ohlcv(symbol, timeframe, limit=limit)
        print(f"   ‚Ä¢ S√≠mbolo: {symbol}")
        print(f"   ‚Ä¢ Timeframe: {timeframe}")
        print(f"   ‚Ä¢ Datos: {len(df)} velas")
        print(f"   ‚Ä¢ Per√≠odo: {df['timestamp'].min()} a {df['timestamp'].max()}")

        # 2. Crear se√±ales de prueba con niveles realistas
        print(f"\n‚ö° CREANDO SE√ëALES DE PRUEBA:")
        signals = create_realistic_signals(df, symbol, timeframe)

    def create_realistic_signals(df, symbol, timeframe):
        """Crear se√±ales con niveles realistas de SL/TP basados en volatilidad"""
        signals = []

        # Analizar volatilidad del dataset
        price_min = df['low'].min()
        price_max = df['high'].max()
        price_range = price_max - price_min
        volatility_pct = (price_range / price_min) * 100

        # Calcular niveles adaptativos basados en volatilidad
        # Para volatilidad baja (<3%), usar niveles m√°s ajustados
        if volatility_pct < 3.0:
            sl_pct = 0.005  # 0.5%
            tp_pct = 0.008  # 0.8%
        elif volatility_pct < 5.0:
            sl_pct = 0.008  # 0.8%
            tp_pct = 0.015  # 1.5%
        else:
            sl_pct = 0.015  # 1.5%
            tp_pct = 0.025  # 2.5%

        print(f"   üìä Volatilidad detectada: {volatility_pct:.2f}%")
        print(f"   üéØ Niveles adaptativos: SL ¬±{sl_pct*100:.1f}%, TP ¬±{tp_pct*100:.1f}%")

        # Se√±al 1: LONG con niveles realistas
        entry_price = df['close'].iloc[20]
        signals.append(TradeSignal(
            timestamp=df['timestamp'].iloc[20],
            symbol=symbol,
            timeframe=timeframe,
            signal_type=SignalType.LONG,
            entry_price=entry_price,
            stop_loss=entry_price * (1 - sl_pct),
            take_profit=entry_price * (1 + tp_pct),
            risk_reward=tp_pct / sl_pct,
            confidence=0.85,
            setup_components={'fvg': True, 'order_block': True},
            confirmation_type=ConfirmationType.ENGULFING
        ))

        # Se√±al 2: SHORT con niveles realistas
        entry_price = df['close'].iloc[40]
        signals.append(TradeSignal(
            timestamp=df['timestamp'].iloc[40],
            symbol=symbol,
            timeframe=timeframe,
            signal_type=SignalType.SHORT,
            entry_price=entry_price,
            stop_loss=entry_price * (1 + sl_pct),
            take_profit=entry_price * (1 - tp_pct),
            risk_reward=tp_pct / sl_pct,
            confidence=0.75,
            setup_components={'fvg': True, 'liquidity': True},
            confirmation_type=ConfirmationType.REJECTION_WICK
        ))

        # Se√±al 3: LONG con niveles ligeramente m√°s amplios
        entry_price = df['close'].iloc[60]
        signals.append(TradeSignal(
            timestamp=df['timestamp'].iloc[60],
            symbol=symbol,
            timeframe=timeframe,
            signal_type=SignalType.LONG,
            entry_price=entry_price,
            stop_loss=entry_price * (1 - sl_pct * 1.2),
            take_profit=entry_price * (1 + tp_pct * 1.2),
            risk_reward=(tp_pct * 1.2) / (sl_pct * 1.2),
            confidence=0.80,
            setup_components={'order_block': True, 'bos': True},
            confirmation_type=ConfirmationType.HAMMER
        ))

        return signals

        print(f"   ‚úÖ {len(signals)} se√±ales creadas:")
        for i, signal in enumerate(signals):
            rr = signal.risk_reward
            print(f"      {i+1}. {signal.signal_type.value} en ${signal.entry_price:.2f} (RR: {rr:.1f})")

        # 3. Configuraci√≥n del backtesting
        print(f"\nüéØ CONFIGURACI√ìN DEL BACKTESTING:")
        initial_capital = 10000
        risk_per_trade = 1.0

        print(f"   ‚Ä¢ Capital inicial: ${initial_capital:,.2f}")
        print(f"   ‚Ä¢ Riesgo por trade: {risk_per_trade}%")
        print(f"   ‚Ä¢ M√°xima duraci√≥n: 48 horas")

        # 4. Ejecutar backtesting
        print(f"\nüöÄ EJECUTANDO BACKTESTING...")

        backtest_result = run_backtest_analysis(
            df=df,
            signals=signals,
            initial_capital=initial_capital,
            risk_per_trade=risk_per_trade
        )

        if not backtest_result['success']:
            print(f"   ‚ùå Error en backtesting: {backtest_result.get('report', 'Error desconocido')}")
            return False

        results = backtest_result['results']

        # 5. Mostrar resultados detallados
        print(f"\nüìà RESULTADOS COMPLETOS:")
        print(f"   üìä Trades ejecutados: {results.total_trades}")
        print(f"   ‚úÖ Ganadores: {results.winning_trades}")
        print(f"   ‚ùå Perdedores: {results.losing_trades}")
        print(f"   ‚öñÔ∏è Breakeven: {results.breakeven_trades}")

        if results.total_trades > 0:
            print(f"   üéØ Win Rate: {results.win_rate:.1f}%")
            print(f"   üí∞ Capital final: ${results.final_capital:,.2f}")
            print(f"   üìà Retorno total: {results.total_return:.2f}%")
            print(f"   üìä Retorno anualizado: {results.annualized_return:.2f}%")
            print(f"   üìâ M√°ximo Drawdown: {results.max_drawdown_percent:.1f}%")
            print(f"   üî¢ Profit Factor: {results.profit_factor:.2f}")
            print(f"   üí∏ Expectancy: ${results.expectancy:.2f} por trade")
            print(f"   ‚è±Ô∏è Duraci√≥n promedio: {results.average_trade_duration:.1f} horas")

        # 6. An√°lisis individual de trades
        if results.trades:
            print(f"\nüìã AN√ÅLISIS INDIVIDUAL DE TRADES:")
            for i, trade in enumerate(results.trades):
                result_icon = "‚úÖ" if trade.result.value == "WIN" else "‚ùå" if trade.result.value == "LOSS" else "‚öñÔ∏è"
                print(f"   {i+1}. {result_icon} {trade.signal_type}")
                print(f"      Entry: ${trade.entry_price:.2f} | Exit: ${trade.exit_price:.2f}")
                print(f"      P&L: {trade.pnl_percent:.2f}% | RR logrado: {trade.risk_reward_achieved:.1f}")
                print(f"      Duraci√≥n: {trade.duration_hours:.1f}h | Fecha: {trade.entry_time}")

        # 7. Verificar componentes del sistema
        print(f"\nüîß VERIFICACI√ìN DE COMPONENTES:")

        components = [
            ("Obtenci√≥n de datos", True),
            ("Creaci√≥n de se√±ales", len(signals) > 0),
            ("Ejecuci√≥n de backtesting", backtest_result['success']),
            ("C√°lculo de trades", results.total_trades > 0),
            ("M√©tricas de performance", results.win_rate >= 0),
            ("Reporte generado", len(backtest_result['report']) > 100),
            ("Gr√°fico de performance", hasattr(backtest_result['chart'], 'data')),
            ("Capital final calculado", results.final_capital > 0),
            ("Retornos calculados", results.total_return != 0 or results.total_trades == 0)
        ]

        all_working = True
        for component, status in components:
            icon = "‚úÖ" if status else "‚ùå"
            print(f"   {icon} {component}")
            if not status:
                all_working = False

        # 8. Mostrar parte del reporte
        print(f"\nüìÑ EXTRACTO DEL REPORTE:")
        report = backtest_result['report']
        report_lines = report.split('\n')[:15]  # Primeras 15 l√≠neas
        for line in report_lines:
            if line.strip():
                print(f"   {line}")

        # 9. Resumen final
        print(f"\n" + "="*80)
        print(f"üèÜ RESUMEN FINAL DEL BACKTESTER SMC")
        print(f"="*80)

        print(f"‚úÖ FUNCIONALIDADES IMPLEMENTADAS:")
        print(f"   üìä Simulaci√≥n de trades realista con SL/TP")
        print(f"   üí∞ Gesti√≥n de capital con riesgo configurable")
        print(f"   üìà M√©tricas completas de performance (Win Rate, Profit Factor, etc.)")
        print(f"   üìâ C√°lculo de drawdown m√°ximo")
        print(f"   ‚è±Ô∏è An√°lisis de duraci√≥n de trades")
        print(f"   üìä Generaci√≥n de gr√°ficos de performance")
        print(f"   üìÑ Reportes detallados en formato Markdown")
        print(f"   üîß Integraci√≥n lista para Streamlit")

        if all_working:
            performance_emoji = "üöÄ" if results.total_return > 0 else "üìâ" if results.total_return < 0 else "‚û°Ô∏è"
            print(f"\n{performance_emoji} ESTADO: COMPLETAMENTE FUNCIONAL")
            if results.total_trades > 0:
                print(f"üìä Performance de prueba: {results.total_return:.2f}% en {results.total_trades} trades")
            print(f"‚úÖ Listo para uso en producci√≥n con se√±ales reales del motor SMC")
        else:
            print(f"\n‚ö†Ô∏è ESTADO: REQUIERE REVISI√ìN MENOR")
            print(f"üìù Algunos componentes necesitan ajustes")

        return all_working

    except Exception as e:
        print(f"\n‚ùå ERROR EN EL TEST FINAL: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    print("üéØ Ejecutando test final del backtester SMC...")
    success = final_backtester_test()

    if success:
        print(f"\nüéâ ¬°BACKTESTER SMC COMPLETAMENTE OPERATIVO!")
        print(f"   üî• Todas las funcionalidades verificadas")
        print(f"   ‚úÖ Listo para integraci√≥n en el dashboard")
    else:
        print(f"\n‚ö†Ô∏è Test completado con observaciones")
        print(f"   üìù Revisar detalles arriba")
